use parse::lexer::Token;

grammar<'input>;

// [1] turtleDoc ::= statement*
pub turtle_doc: () = { statement* };

// [2] statement ::= directive | triples '.'
statement: () = {
    directive,
    triples ".",
};

// [3]  directive ::= prefixID | base | sparqlPrefix | sparqlBase
directive: () = {
    prefix_id,
    base,
    sparql_prefix,
    sparql_base,
};

// [4] prefixID ::= '@prefix' PNAME_NS IRIREF '.'
prefix_id: () = {
    "@prefix" "PNAME_NS" "IRIREF" ".",
};

// [5] base ::= '@base' IRIREF '.'
base: () = {
    "@base" "IRIREF" ".",
};

// [5s] sparqlBase ::= "BASE" IRIREF
sparql_base: () = {
    "BASE" "IRIREF",
};

// [6s] sparqlPrefix ::= "PREFIX" PNAME_NS IRIREF
sparql_prefix: () = {
    "PREFIX" "PNAME_NS" "IRIREF",
};

// [6] triples ::= subject predicateObjectList | blankNodePropertyList predicateObjectList?
triples: () = {
    subject predicateObjectList,
    blankNodePropertyList predicateObjectList?
};

// [7] predicateObjectList ::= verb objectList (';' (verb objectList)?)*
predicateObjectList: () = verb objectList (";" (verb objectList)?)*;

// [8] objectList ::= object (',' object)*
objectList: () = object ("," object)*;

// [9] verb ::= predicate | 'a'
verb: () = {
    predicate,
    "a",
};

// [10] subject ::= iri | BlankNode | collection
subject: () = {
    iri,
    BlankNode,
    collection,
};

// [11] predicate ::= iri
predicate: () = iri;

// [12] object ::= iri | BlankNode | collection | blankNodePropertyList | literal
object: () = {
    iri,
    BlankNode,
    collection,
    blankNodePropertyList,
    literal,
};

// [13] literal ::= RDFLiteral | NumericLiteral | BooleanLiteral
literal: () = {
    RDFLiteral,
    NumericLiteral,
    BooleanLiteral,
};

// [14] blankNodePropertyList ::= '[' predicateObjectList ']'
blankNodePropertyList: () = "[" predicateObjectList "]";

// [15] collection ::= '(' object* ')'
collection: () = "(" object* ")";

// [16] NumericLiteral ::= INTEGER | DECIMAL | DOUBLE
NumericLiteral: () = {
    "INTEGER",
    "DECIMAL",
    "DOUBLE",
};

// [128s] RDFLiteral ::= String (LANGTAG | '^^' iri)?
RDFLiteral: () = {
    String "LANGTAG",
    String "^^" iri,
    String,
};

// [133s] BooleanLiteral ::= 'true' | 'false'
BooleanLiteral: () = {
    "true",
    "false",
};

// [17] String ::= STRING_LITERAL_QUOTE | STRING_LITERAL_SINGLE_QUOTE | STRING_LITERAL_LONG_SINGLE_QUOTE | STRING_LITERAL_LONG_QUOTE
String: () = {
    "STRING_LITERAL_QUOTE",
};

// [135s] iri ::= IRIREF | PrefixedName
iri: () = {
    "IRIREF",
    PrefixedName,
};

// [136s] PrefixedName ::= PNAME_LN | PNAME_NS
PrefixedName: () = {
    "PNAME_LN",
    "PNAME_NS",
};

// [137s] BlankNode ::= BLANK_NODE_LABEL | ANON
BlankNode: () = {
    "BLANK_NODE_LABEL",
    "ANON",
};

extern {
    type Location = usize;

    enum Token<'input> {
        "." => Token::Period,
        "," => Token::Comma,
        ";" => Token::SemiColon,
        "[" => Token::LeftBracket,
        "]" => Token::RightBracket,
        "(" => Token::LeftParen,
        ")" => Token::RightParen,
        "^^" => Token::Carets,
        "a" => Token::A,
        "true" => Token::True,
        "false" => Token::False,
        "@prefix" => Token::Prefix,
        "@base" => Token::Base,
        "PREFIX" => Token::SparqlPrefix,
        "BASE" => Token::SparqlBase,
        "PNAME_LN" => Token::PNAME_LN,
        "PNAME_NS" => Token::PNAME_NS,
        "IRIREF" => Token::IRIRef(<&'input str>),
        "LANGTAG" => Token::LangTag(<&'input str>),
        "INTEGER" => Token::Integer,
        "DECIMAL" => Token::Decimal,
        "DOUBLE" => Token::Double,
        "STRING_LITERAL_QUOTE" => Token::StringLiteralQuote(<&'input str>),
        "BLANK_NODE_LABEL" => Token::BlankNodeLabel(<&'input str>),
        "ANON" => Token::ANON,
        "COMMENT" => Token::Comment(<&'input str>),
    }
}
